---
import cursor from './progress_full.png'
---

<div class="flex items-center gap-3">
	<div class="relative h-10 w-[300px] overflow-hidden rounded-md">
		<!-- Hidden content -->
		<div class="absolute inset-0 flex items-center px-3 select-none">
			<span class="text-foreground text-sm">hello world</span>
		</div>
		<!-- Scratchable area -->
		<canvas id="canvas" width="300" height="200" class="absolute h-full w-full"
		></canvas>
	</div>
	<button
		id="copy-button"
		class="transform-all flex size-4 items-center justify-center opacity-0"
		title="Copy code"
	>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="24"
			height="24"
			viewBox="0 0 24 24"
			fill="none"
			stroke="currentColor"
			stroke-width="2"
			stroke-linecap="round"
			stroke-linejoin="round"
			class="lucide lucide-copy-icon lucide-copy"
			><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path
				d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg
		>
	</button>
</div>

<script>
	const copyButton = document.getElementById('copy-button')
	const canvas = document.getElementById('canvas') as HTMLCanvasElement
	const ctx = canvas.getContext('2d')
	if (!ctx) {
		throw new Error('Canvas element not found')
	}

	canvas.width = canvas.offsetWidth
	canvas.height = canvas.offsetHeight
	canvas.style.cursor = `url("/progress_full.png") 16 16, auto`

	// 1. Draw metallic gradient
	const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height)
	gradient.addColorStop(0, '#d9d9d9')
	gradient.addColorStop(1, '#a6a6a6')
	ctx.fillStyle = gradient
	ctx.fillRect(0, 0, canvas.width, canvas.height)

	// 2. Add metallic noise (procedural, no external image)
	const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
	const data = imageData.data
	for (let i = 0; i < data.length; i += 4) {
		const rand = (Math.random() - 0.5) * 50 // noise intensity
		data[i] += rand // R
		data[i + 1] += rand // G
		data[i + 2] += rand // B
	}
	ctx.putImageData(imageData, 0, 0)

	// 3. Scratch logic
	let isDrawing = false

	let lastX = 0
	let lastY = 0

	ctx.lineJoin = 'round'
	ctx.lineCap = 'round'
	ctx.globalCompositeOperation = 'destination-out'
	ctx.lineWidth = 20

	canvas.addEventListener('mousedown', startDrawing)
	document.addEventListener('mouseup', stopDrawing)
	canvas.addEventListener('mousemove', scratch)
	canvas.addEventListener('mouseenter', (e: MouseEvent) => {
		if (isDrawing) {
			// restart coordinates if mouse left and re-entered while drawing
			const { offsetX, offsetY } = e
			// guardar las coordenadas iniciales
			lastX = offsetX
			lastY = offsetY
		}
	})

	canvas.addEventListener('touchstart', startDrawing)
	document.addEventListener('touchend', stopDrawing)
	canvas.addEventListener('touchmove', scratch)

	function startDrawing(e: MouseEvent | TouchEvent) {
		isDrawing = true
		const { offsetX, offsetY } = e
		// guardar las coordenadas iniciales

		lastX = offsetX
		lastY = offsetY
	}

	function stopDrawing() {
		isDrawing = false
		const erasedPercentage = getErasedPercentage()

		if (erasedPercentage > 90 && copyButton) {
			copyButton.style.opacity = '1'
		}
	}

	function getErasedPercentage() {
		const imageData = ctx!.getImageData(0, 0, canvas.width, canvas.height)
		const data = imageData.data
		let erasedPixels = 0

		// Each pixel has 4 values (R, G, B, A)
		for (let i = 3; i < data.length; i += 4) {
			if (data[i] === 0) erasedPixels++ // alpha = 0 means erased
		}

		const totalPixels = canvas.width * canvas.height

		return (erasedPixels / totalPixels) * 100 // percentage
	}

	function scratch(e: MouseEvent | TouchEvent) {
		if (!isDrawing || !ctx) return

		let x: number, y: number
		if ('touches' in e) {
			e.preventDefault() // Prevent scrolling
			// Handle touch events
			const rect = canvas.getBoundingClientRect()
			x = e.touches[0].clientX - rect.left
			y = e.touches[0].clientY - rect.top
		} else {
			// Handle mouse events
			x = e.offsetX
			y = e.offsetY
		}

		ctx.beginPath()
		ctx.moveTo(lastX, lastY)
		ctx.lineTo(x, y)

		ctx.stroke()

		lastX = x
		lastY = y
	}
</script>
