---
title: 'Sparkling Text'
pubDate: 2025-10-01
description: 'Adding sparkles to emphasize positive text'
tags: ['react', 'animation']
draft: false
---

import SparklingText from '~/components/demos/sparkling-text.tsx'
import Demo from '~/components/demos/demo.astro'

Recently, I stumbled upon [Linear's stunning Readme page](https://linear.app/readme).
If you haven't checked it out yet, I'd recommend you to do so.
It's not just a "readme", it's a nostalgic journey through the early magical days of the internet.
A reflection on how things changed and Linear's mission to revive that sense of wonder.

One detail that really caught my eye on this page was their use of
delightful text effects. Among them, this highlighted text that sparkles when you hover:

<Demo>
  <div class="flex h-[100px] items-center justify-center">
    <SparklingText client:load>A magical moment.</SparklingText>
  </div>
</Demo>

It instantly reminded me of [this Sparkles component](https://www.joshwcomeau.com/react/animated-sparkles-in-react/)
that Josh Comeau put together some time ago.

Linear's version adds a couple of touches, and in this post I’m going to explore how Linear’s component was built.

## Text with moving background

To achieve the moving background color gradient effect, we add first the background of the text element:

```css
--a: #db91cb;
--b: #9a5eff;
background: linear-gradient(120deg, var(--a) 0%, var(--b) 50%, var(--a) 100%);
```

Then, by using `background-clip: text` and `-webkit-text-fill-color: transparent` to make the text transparent,
we ensure that the gradient is visible only within the text itself, rather than behind it.

Finally, we set the `background-size: 200% auto`, which ensures the gradient is wide enough for a smooth transition.
By animating background-position to -200%, the text appears to shift gradually from one color to another:

```css
animation: 3s linear infinite forwards backgroundShift;

@keyframes backgroundShift {
  100% {
    background-position: -200% center;
  }
}
```

## Animating the sparkle

Each of the sparkles consist of an `svg`, which I directly used Linear's:

<div className="flex items-center justify-center">
  <svg width="20" height="20" viewBox="0 0 68 68" fill="#8253D5">
    <path d="M26.5 25.5C19.0043 33.3697 0 34 0 34C0 34 19.1013 35.3684 26.5 43.5C33.234 50.901 34 68 34 68C34 68 36.9884 50.7065 44.5 43.5C51.6431 36.647 68 34 68 34C68 34 51.6947 32.0939 44.5 25.5C36.5605 18.2235 34 0 34 0C34 0 33.6591 17.9837 26.5 25.5Z"></path>
  </svg>
</div>

Each sparkle uses a combination of scaling and rotating keyframe animations to twinkle.

To achieve that, we'll create a wrapper around the svg so we can keep the two animations separate and have more control over the duration and timing functions:

```html
<span class="sparkle__sparkle">
  <svg width="20" height="20" viewBox="0 0 68 68" fill="#8253D5">
    <path
      d="M26.5 25.5C19.0043 33.3697 0 34 0 34C0 34 19.1013 35.3684 26.5 43.5C33.234 50.901 34 68 34 68C34 68 36.9884 50.7065 44.5 43.5C51.6431 36.647 68 34 68 34C68 34 51.6947 32.0939 44.5 25.5C36.5605 18.2235 34 0 34 0C34 0 33.6591 17.9837 26.5 25.5Z"
    ></path>
  </svg>
</span>
```

Then add the scaling animation to the wrapper:

```css
.sparkle__sparkle {
  /* rest of styles */
  animation: 700ms ease 0s 1 normal forwards comeInOut;
}

@keyframes comeInOut {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
```

And the spinning animation to the svg:

```css
.sparkle__sparkle svg {
  /* rest of styles */
  animation: 1000ms linear 0s 1 normal none spin;
}
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(180deg);
  }
}
```

## Generating sparkles

Now that we have the sparkle element and its animation, we need to generate them sequentally.
Each sparkle will have a `createdAt` timestamp that we will use as its ID, and a random position:

```ts
function randomInRange(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

type Sparkle = { style: CSSProperties; createdAt: number }

function generateSparkle(): Sparkle {
  const left = randomInRange(-20, 120) + '%'
  const top = randomInRange(-20, 120) + '%'

  return { style: { left, top }, createdAt: Date.now() }
}
```

The position is randomized between -20% and 120% of the container element's width and height so the sparkles can also render slightly outside this element.

## Generation and cleanup

The component uses two state variables: one to track whether it's actively animating, and another to maintain an array of sparkle positions.
Sparkles are generated using `setInterval`. On each interval, we create a new sparkle and add it to the beginning of the array.

To prevent polluting the DOM with stale sparkle elements, we slice the array to keep only the 3 most recent sparkles—when a fourth sparkle is added, the oldest one (at the end of the array) is automatically removed.
The timing is carefully calibrated: sparkles generate every 250ms by default, while each sparkle's scaling animation lasts 700ms. This gives sparkles enough time to complete their animation before being cleaned up.

```tsx
const SparklingText: FunctionalComponent<Props> = ({ children }) => {
  const [isAnimating, setIsAnimating] = useState(false)
  const [sparkles, setSparkles] = useState<Sparkle[]>([])

  useEffect(() => {
    if (!isAnimating) return

    const interval = setInterval(() => {
      setSparkles(prev => [generateSparkle(), ...prev].slice(0, 3))
    }, 250)

    return () => clearInterval(interval)
  }, [isAnimating])

  return (
    <div class={styles.sparkle__container}>
      {sparkles.map(sparkle => (
        <span
          key={sparkle.createdAt}
          class={styles.sparkle__sparkle}
          style={sparkle.style}
        >
          <svg width="20" height="20" viewBox="0 0 68 68" fill="#8253D5">
            <path d="M26.5 25.5C19.0043 33.3697 0 34 0 34C0 34 19.1013 35.3684 26.5 43.5C33.234 50.901 34 68 34 68C34 68 36.9884 50.7065 44.5 43.5C51.6431 36.647 68 34 68 34C68 34 51.6947 32.0939 44.5 25.5C36.5605 18.2235 34 0 34 0C34 0 33.6591 17.9837 26.5 25.5Z"></path>
          </svg>
        </span>
      ))}

      <span class={styles.sparkle__text}>{children}</span>
    </div>
  )
}
```

Another important detail is that we use each sparkle's `createdAt` timestamp as its React key.
This ensures React treats each sparkle as a new element, properly triggering the CSS animation on mount.

## Triggering the animation

To make the sparkles appear on hover, we add pointer event listeners to the container:

```tsx
<span
  class={styles.sparkle__container}
  onPointerEnter={() => setIsAnimating(true)}
  onPointerLeave={() => setIsAnimating(false)}
>
  {/* Same code...*/}
</span>
```

Another consideration: mobile devices don't support hover interactions, so on touch devices we'll show the animation continuously instead.

To handle this, we can add a hook that detects whether hover is supported. If it's not, we automatically trigger the animation on mount:

```tsx
useEffect(() => {
  const isHoverUnsupported = window.matchMedia('(hover: none)').matches

  if (isHoverUnsupported) {
    setIsAnimating(true)
  }
}, [])
```

## Pulling it all together

Here's the final version of the component we've built:

```tsx
const SparklingText: FunctionalComponent<Props> = ({ children }) => {
  const [isAnimating, setIsAnimating] = useState(false)
  const [sparkles, setSparkles] = useState<Sparkle[]>([])

  useEffect(() => {
    const isHoverUnsupported = window.matchMedia('(hover: none)').matches

    if (isHoverUnsupported) {
      setIsAnimating(true)
    }
  }, [])

  useEffect(() => {
    if (!isAnimating) return

    const interval = setInterval(() => {
      setSparkles(prev => [generateSparkle(), ...prev].slice(0, 3))
    }, 250)

    return () => clearInterval(interval)
  }, [isAnimating])

  return (
    <span
      class={styles.sparkle__container}
      onPointerEnter={() => setIsAnimating(true)}
      onPointerLeave={() => setIsAnimating(false)}
    >
      {sparkles.map(sparkle => (
        <span
          key={sparkle.createdAt}
          class={styles.sparkle__sparkle}
          style={sparkle.style}
        >
          <svg width="20" height="20" viewBox="0 0 68 68" fill="#8253D5">
            <path d="M26.5 25.5C19.0043 33.3697 0 34 0 34C0 34 19.1013 35.3684 26.5 43.5C33.234 50.901 34 68 34 68C34 68 36.9884 50.7065 44.5 43.5C51.6431 36.647 68 34 68 34C68 34 51.6947 32.0939 44.5 25.5C36.5605 18.2235 34 0 34 0C34 0 33.6591 17.9837 26.5 25.5Z"></path>
          </svg>
        </span>
      ))}

      <span class={styles.sparkle__text}>{children}</span>
    </span>
  )
}
```

You can see the complete implementation details in the [source code](http://github.com/vgarmes/vgarmes.github.io/blob/main/src/components/demos/sparkling-text.tsx)
and if you found this useful please drop a like! Thanks for reading.
