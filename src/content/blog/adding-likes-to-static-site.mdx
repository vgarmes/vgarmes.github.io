---
title: 'Adding likes to a static site'
pubDate: 2023-09-15
description: ''
image:
  url: 'https://res.cloudinary.com/dx73a1lse/image/upload/v1691097664/blog/build-your-own-react-routerwebp_wzdy1w.webp'
  alt: 'Thumbnail with the blog post title'
tags: ['cloudflare', 'hono', 'drizzle']
draft: true
---

import LikeButtonDemo from '../../components/LikeButton/LikeButtonDemo.tsx'

When I started revamping my personal site I wanted to make it really performant. Given that my site primarily consists of static content, I found the ideal solution in Astro, a framework focused on speed and efficiency. Astro's promise of generating static pages with minimal JavaScript and adhering to a library-agnostic islands architecture aligned perfectly with my needs.

However, even on static sites like this, there usually arises a need for backend functionality - whether it's tallying the blog post views or enabling readers to like and comment on posts. In my case, I wanted readers to be able to like my blog posts, without the need for authentication.

For such modest web APIs, my go-to technology is Cloudflare. With a very generous free tier, Cloudflare has a technology called Workers which allows you to quickly set up serverless api endpoints, instantly deployed across their Edge network spanning 300 global locations.

What's more, Cloudflare has introduced a database solution, D1 (in open alpha by the time this was written), which caters to my needs.

Since I wanted to take full advantage of the Workers Edge runtime, I used technologies that support it:

- Hono: backend framewor similar to Express but it runs on CDN Edges.
- Drizzle: ORM that integrates with the Edge runtime
- D1 database: a SQLite-based database

In this blog post, I'll guide you through the process of improving my blog by adding a post liking functionality using these technologies. This approach can be extended to incorporate various backend features, making it helpful for anyone who wants to add these to their static sites.

## Getting ready

First of all, you'll need to create a Cloudflare account if you haven't already. With this account you will have access to your dashboard where you can set up and monitor your Workers and the D1 database.

Then, you'll need the Workers command-line interface, Wrangler, which allows to easily create, test and deploy Workers projects. For using it, you can decide whether installing it in your global packages with `npm -g wrangler` or using it dirctly with `npx`.

Running the command `wrangler dev` will start a local server on `http://localhost:8787` for developing our Worker. However, if you try to go to that route you'll get a 404 because we haven't built our API yet.

Moreover, you'll need to create a `wrangler.toml` file at the root of your project. This file will be used to configure our Worker. We can already start the first configuration by adding this to the file:

```toml
name = <WORKER_NAME>
main = <WORKER_ENTRY_POINT> # i.e "src/api/index.ts"
compatibility_date = "2023-08-07"
node_compat = true
```

### Creating a database

To create our D1 database with Cloudflare, we just need to run

```shell
wrangler d1 create <DATABASE_NAME>
```

This will create a new D1 database, and output the binding configuration like below which we'll needed in the next step:

```shell
[[d1_databases]]
binding = "DB"
database_name = "<DATABASE_NAME>"
database_id = "<unique-ID-for-your-database>"
```

### Binding your Worker to the D1 database

You must create a binding for your Worker to connect to your D1 database. Bindings allow your Workers to access resources, like D1, on the Cloudflare developer platform. You create bindings by updating your wrangler.toml file.

To bind your D1 database to your Worker, add the following to the end of your `wrangler.toml` file which we previously created:

```toml
[[d1_databases]]
binding = "DB" # i.e. available in your Worker on env.DB
database_name = "<DATABASE_NAME>"
database_id = "<unique-ID-for-your-database>"
```

The value (string) you set for `<BINDING_NAME>` will be used to reference this database in your Worker and it is available in your Worker's environent at `env.<BINDING_NAME>` as we'll see later on. The name can be any valid JavaScript variable name, in my case I've just called it `DB`.

### Installing the rest of the dependencies

Install hono
`pnpm install hono`

Install drizzle

If you use Typescript, you'll also want to install the types for Workers:

`pnpm install -D @cloudflare/workers-types`

and add it to your types in your `tsconfig.json` file:

```json
{
	"compilerOptions": {
		"types": ["@cloudflare/workers-types"]
	}
}
```

## Creating the database

Now that we have our D1 database ready, we can create the schema with Drizzle. One of the cool things about Drizzle, it's that it lets you define and manage the database schema in typescript.

First we'll create the table `Posts`, where we will store each post's slug and the total amount of likes and views:

```ts
export const posts = sqliteTable(
	'posts',
	{
		id: integer('id').primaryKey({ autoIncrement: true }),
		slug: text('slug').notNull(),
		totalLikes: integer('total_likes').default(0),
		totalViews: integer('total_views').default(0)
	},
	table => ({
		slugIdx: uniqueIndex('slugIdx').on(table.slug)
	})
)
```

As you can see, I added the slug as index of the table since that's the way it's going to be filtered in most cases.

Then we can create the table that will keep track of the user likes:

```ts
export const userLikes = sqliteTable(
	'user_likes',
	{
		userId: text('user_id'),
		postId: integer('post_id').references(() => posts.id),
		likes: integer('likes').default(1)
	},
	table => {
		return {
			pk: primaryKey(table.userId, table.postId)
		}
	}
)
```

At the time of writing this article, there was [a bug with D1](https://github.com/cloudflare/workers-sdk/issues/3160) when trying to left join 2 tables that have the same column names, for which the second column is not returned. Hence why I used different naming for the likes and views in each of the tables.

Whenever you apply changes to the schema - you just run:

```shell
drizzle-kit generate:sqlite
```

For my own convenience I added this as a script in `package.json`.

To init local database and run server locally:

```shell
wrangler d1 execute <DATABASE_NAME> --local --file=./drizzle/<FILE_NAME>.sql
wrangler dev --local --persist
```

`FILE_NAME` something that will look like `0000_short_lockheed`

## Creating the web APIs with Hono

For the web APIs we'll use Hono, which is a simple backend famework similar to Express but it runs on Edge networks.

With something as simple as this we can already have a Worker set up

```ts
const app = new Hono()

app.get('hello-world', c => c.text('hello world!'))
```

### Identifying the user on each request

Since I wanted to give the possibility to like the posts without the need of creating an account and being authenticated, I identify the users using the origin IP address in the request. However, in order to anonymize the user and not keep any sensitive data I hash this information.

We have easy access to the request ip by using the context of the request and getting the header `cf-connecting-ip` provided by the Cloudflare Worker. Then we can hash the ip using an encryption algorithm like `SHA-256` and salt in order to generate the user id:

```ts
const ipAddress = c.req.header('cf-connecting-ip') || '0.0.0.0'
const salt = c.env.IP_ADDRESS_SALT
const currentUserId = await hashIpAddress(ipAddress, salt)
```

I ommited the definition of the function `hashIpAddress` for keeping it short but you can refer to my source code.

## Fetching the post and user statistics

As previously mentioned, we have access to Cloudflare resources using bindings. If you called the D1 database binding `DB`, you can retrieve it in our Hono endpoints using the request context under `c.env.DB`.

These bindings can also include environment variables, which can be configured creating a `.dev.vars` file in development and deploy them to production using the command `CHANGE THIS`. In my case I used this to store an `IP_ADDRESS_SALT` salt value to hash the ip addresses.

We can pass Generics to specify the types of these Bindings when initializing Hono, for example:

```ts
type Bindings = {
	DB: D1Database
	IP_ADDRESS_SALT: string
}

const app = new Hono<{ Bindings: Bindings }>()
```

```ts
app.get('/api/posts/:slug/stats', async c => {
	const db = drizzle(c.env.DB)
	const slug = c.req.param('slug')
	const ipAddress = c.req.header('cf-connecting-ip') || '0.0.0.0'
	const salt = c.env.IP_ADDRESS_SALT
	const currentUserId = await hashIpAddress(ipAddress, salt)
	const post = await db.select().from(posts).where(eq(posts.slug, slug)).get()

	if (!post) {
		return c.text('Post not found in database', 404)
	}

	const currentUserLikes = await db
		.select()
		.from(userLikes)
		.where(
			and(eq(userLikes.postId, post.id), eq(userLikes.userId, currentUserId))
		)
		.get()

	return c.json({
		slug,
		totalViews: post.totalViews,
		totalLikes: post.totalLikes,
		userLikes: currentUserLikes?.likes ?? 0
	})

```

## Storing the user's likes

For storing the user's likes, I just created a new endpoint similary to the one above but with the `POST` method. With Hono, this is as simple as creating the endpoint as:

```ts
app.post('/api/posts/:slug/like', async c => {
	// ...rest of the logic
})
```

Without getting into many details, what this endpoint does is first identify the user and fetch the amount of likes this user has for the corresponding blog post. If this exceeds the set limits, we return an error. Otherwise we proceed to update both the posts and user likes database tables.

## Building the Like Button component in React

For the like button, I made a component in React with a design inspired by [Delba Oliveira's](https://delba.dev/blog/a-like-button-that-likes-you-back) but with a few changes and tweaks like the small confetti animation when the use reach the maximum number of likes. You can play around with the component here:

<LikeButtonDemo client:visible />

## Using API in the client and batching requests

## Deploy the worker and database

Before deploying your D1 database and Worker globally, log in with your Cloudflare account by running:

```shell
wrangler login
```

To deploy the worker, run:

```shell
wrangler deploy
```

npx wrangler deploy

```shell
wrangler d1 execute <DATABASE_NAME> --file=./schema.sql
```
